=> SO_REUSEADDR is an option that allows you to reuse local addresses.

=> The poll function in C/C++ is used for monitoring multiple file descriptors 
to see if any of them become ready for I/O operations. 

=> struct pollfd objects, where each object represents a file descriptor you want to monitor. 
Each struct pollfd contains the file descriptor (fd) and events to monitor (events).

=> events field to specify the events you're interested in , POLLIN for data to read .

=> revents field to check for specific events , POLLIN for data to read .

=> int poll(struct pollfd *fds, nfds_t nfds, int timeout);

struct pollfd {
    int fd;         // file descriptor to be monitored
    short events;   // events to monitor (input and output events)
    short revents;  // returned events (output only)
};

returns the number of file descriptors that have events , errors returns -1

=> fcntl: used for file control.

int fcntl(int fd, int cmd, ... /* arg */);

in network programming, "blocking" refers to a situation where a program halts its execution until a particular operation completes .
when you try to read data from a socket in blocking mode and there's no data available, the program will wait until data arrives before proceeding.

_SETFL: a flag used to indicate that you want to set the file status flags of the specified file descriptor. 

O_NONBLOCK: This is a flag that indicates non-blocking mode. 
When set on a socket, it means that I/O operations on that socket won't block 
the calling process even if there is no data available.


<<<<<<< HEAD
int socket(int domain, int type, int protocol);

Specifies the communication domain in which the socket should be created.

AF_INET for IPv4 Internet protocols.
AF_INET6 for IPv6 Internet protocols.
AF_UNIX for Unix domain sockets.

Specifies the type of communication semantics to be used.

SOCK_STREAM for TCP (stream-oriented) sockets.
SOCK_DGRAM for UDP (datagram-oriented) sockets.
SOCK_RAW for raw sockets, which provide access to underlying network protocols.

Protocol: Specifies the specific protocol to be used. Usually set to 0, 
which allows the system to choose the appropriate protocol based on the specified domain and type.

The bind() function is used to bind a socket to a specific address and port.

int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

1- The file descriptor returned by socket().

2 - A pointer to a structure that specifies the local address to which the socket should be bound. 
For IPv4 sockets, this is typically a struct sockaddr_in structure.
for IPv6 sockets, it's usually a struct sockaddr_in6.

Address Structure Size: The size of the address structure.

struct sockaddr_in {
    short            sin_family;   // Address family (AF_INET)
    unsigned short   sin_port;     // Port number
    struct in_addr   sin_addr;     // IPv4 address (INADDR_ANY Address to accept any incoming messages.)
    char             sin_zero[8];  // Unused (padding to match size of struct sockaddr)
};

The listen() function is used to set up a socket to accept incoming connections. 

int listen(int sockfd, int backlog);

1 - Socket File Descriptor: The file descriptor representing the socket that you want to listen on.

2 - Backlog: The maximum length to which the queue of pending connections for the socket may grow. 
This parameter defines the maximum number of connections that can be waiting to be accepted.
----------------------------------------------------------------------

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

The accept() function is used to accept a connection on a socket that has been set up with listen(). It blocks until a client connection is established.

1 - Socket File Descriptor: The file descriptor representing the socket that is being listened on.

2 - Client Address Pointer: A pointer to a structure where the address of the client connection will be stored. This is usually a struct sockaddr pointer.

3 - Client Address Length Pointer: A pointer to a variable that specifies the size of the client address structure.

----------------------------------------------------------------------

ssize_t recv(int sockfd, void *buf, size_t len, int flags);

Think of recv() as receiving a message from someone. It's used to receive data on a socket.

Socket File Descriptor: This is the file descriptor of the socket where you're expecting to receive data.

Buffer: This is the memory location where the received data will be stored.

Buffer Size: This specifies the maximum number of bytes you're willing to receive in one go.

Flags: These are additional options you can specify. Often set to 0 for basic usage.

----------------------------------------------------------------------

ssize_t send(int sockfd, const void *buf, size_t len, int flags);

Now, send() is like sending a message to someone. It's used to send data on a socket. 

Socket File Descriptor: This is the file descriptor of the socket through which you want to send data.

Buffer: This is the memory location where the data you want to send is stored.

Buffer Size: This specifies the size of the data you want to send.

Flags: Additional options you can specify. often set to 0 for basic usage

----------------------------------------------------------------------

int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);

setsockopt is a function used to set options associated with a socket. 
It allows you to control various aspects of socket behavior .


-----------------------------------------------------------------------

The select() system call in Linux is a mechanism for monitoring multiple
file descriptors, waiting until one or more of the file descriptors become
"ready" for some class of I/O operation 


PASS 369
NICK u0op00
USER tyue f f g
=======

///////// ERRORS ////////////////
#define ERR_NEEDMODEPARM(channelname, mode) (": 696 #" + channelname + " * You must specify a parameter for the key mode. " + mode + CRLF)
#define ERR_INVALIDMODEPARM(channelname, mode) ": 696 #" + channelname + " Invalid mode parameter. " + mode + CRLF
#define ERR_KEYSET(channelname) ": 467 #" + channelname + " Channel key already set. " + CRLF
#define ERR_UNKNOWNMODE(nickname, channelname, mode) ": 472 " + nickname + " #" + channelname + " " + mode + " :is not a recognised channel mode" + CRLF
#define ERR_NOTENOUGHPARAM(nickname) (": 461 " + nickname + " :Not enough parameters." + CRLF)
#define ERR_CHANNELNOTFOUND(nickname, channelname) (": 403 " + nickname + " " + channelname + " :No such channel" + CRLF)
#define ERR_NOTOPERATOR(channelname) (": 482 #" + channelname + " :You're not a channel operator" + CRLF)
#define ERR_NOSUCHNICK(channelname, name) (": 401 #" + channelname + " " + name + " :No such nick/channel" + CRLF )
#define ERR_INCORPASS(nickname) (": 464 " + nickname + " :Password incorrect !" + CRLF )
#define ERR_ALREADYREGISTERED(nickname) (": 462 " + nickname + " :You may not reregister !" + CRLF )
#define ERR_NONICKNAME(nickname) (": 431 " + nickname + " :No nickname given" + CRLF )
#define ERR_NICKINUSE(nickname) (": 433 " + nickname + " :Nickname is already in use" + CRLF)
#define ERR_ERRONEUSNICK(nickname) (": 432 " + nickname + " :Erroneus nickname" + CRLF)
#define ERR_NOTREGISTERED(nickname) (": 451 " + nickname + " :You have not registered!" + CRLF)
#define ERR_CMDNOTFOUND(nickname, command) (": 421 " + nickname + " " + command + " :Unknown command" + CRLF)
>>>>>>> origin/zlaarous
