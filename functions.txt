int socket(int domain, int type, int protocol);

Specifies the communication domain in which the socket should be created.

AF_INET for IPv4 Internet protocols.
AF_INET6 for IPv6 Internet protocols.
AF_UNIX for Unix domain sockets.

Specifies the type of communication semantics to be used.

SOCK_STREAM for TCP (stream-oriented) sockets.
SOCK_DGRAM for UDP (datagram-oriented) sockets.
SOCK_RAW for raw sockets, which provide access to underlying network protocols.

Protocol: Specifies the specific protocol to be used. Usually set to 0, 
which allows the system to choose the appropriate protocol based on the specified domain and type.

The bind() function is used to bind a socket to a specific address and port.

int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

1- The file descriptor returned by socket().

2 - A pointer to a structure that specifies the local address to which the socket should be bound. 
For IPv4 sockets, this is typically a struct sockaddr_in structure.
for IPv6 sockets, it's usually a struct sockaddr_in6.

Address Structure Size: The size of the address structure.

struct sockaddr_in {
    short            sin_family;   // Address family (AF_INET)
    unsigned short   sin_port;     // Port number
    struct in_addr   sin_addr;     // IPv4 address (INADDR_ANY Address to accept any incoming messages.)
    char             sin_zero[8];  // Unused (padding to match size of struct sockaddr)
};

The listen() function is used to set up a socket to accept incoming connections. 

int listen(int sockfd, int backlog);

1 - Socket File Descriptor: The file descriptor representing the socket that you want to listen on.

2 - Backlog: The maximum length to which the queue of pending connections for the socket may grow. 
This parameter defines the maximum number of connections that can be waiting to be accepted.
----------------------------------------------------------------------

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

The accept() function is used to accept a connection on a socket that has been set up with listen(). It blocks until a client connection is established.

1 - Socket File Descriptor: The file descriptor representing the socket that is being listened on.

2 - Client Address Pointer: A pointer to a structure where the address of the client connection will be stored. This is usually a struct sockaddr pointer.

3 - Client Address Length Pointer: A pointer to a variable that specifies the size of the client address structure.

----------------------------------------------------------------------

ssize_t recv(int sockfd, void *buf, size_t len, int flags);

Think of recv() as receiving a message from someone. It's used to receive data on a socket.

Socket File Descriptor: This is the file descriptor of the socket where you're expecting to receive data.

Buffer: This is the memory location where the received data will be stored.

Buffer Size: This specifies the maximum number of bytes you're willing to receive in one go.

Flags: These are additional options you can specify. Often set to 0 for basic usage.

----------------------------------------------------------------------

ssize_t send(int sockfd, const void *buf, size_t len, int flags);

Now, send() is like sending a message to someone. It's used to send data on a socket. 

Socket File Descriptor: This is the file descriptor of the socket through which you want to send data.

Buffer: This is the memory location where the data you want to send is stored.

Buffer Size: This specifies the size of the data you want to send.

Flags: Additional options you can specify. often set to 0 for basic usage

----------------------------------------------------------------------

int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);

setsockopt is a function used to set options associated with a socket. 
It allows you to control various aspects of socket behavior .


-----------------------------------------------------------------------

The select() system call in Linux is a mechanism for monitoring multiple
file descriptors, waiting until one or more of the file descriptors become
"ready" for some class of I/O operation 


PASS 369
NICK atye3
USER tyue